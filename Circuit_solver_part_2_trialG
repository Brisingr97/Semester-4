#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "struct.h"
#include "inv.h"

extern int screenx,screeny,endx,endy;

extern int count;
extern int compc;
int check_net=0;

struct nodemain
{
    	int  net;
		struct nodech *child;
    	struct nodemain *next;
};

struct nodech{
	circuit_component cir;
	struct nodech* next;
};

struct nodevis{
	int  data;
	int x,y;
    struct nodevis *next;
};

struct nodemain* push_main(struct nodemain** head, int net)
{
    if(check_net==1){
	    struct nodemain* new_node = (struct nodemain*)malloc(sizeof(struct nodemain));
	    new_node->net=net;
	    new_node->child=NULL;
	    new_node->next = (*head)->next;
	    (*head)->next    = new_node;
	    return new_node;	
    }
    else{
	    if(net==-1)
		check_net=1;
	    struct nodemain* new_node = (struct nodemain*)malloc(sizeof(struct nodemain));
	    new_node->net=net;
	    new_node->child=NULL;
	    new_node->next = (*head);
	    (*head)    = new_node;
	    return new_node;
    }
}

void push_struct(struct nodech** head, circuit_component cir_comp)
{
    struct nodech* new_node = (struct nodech*)malloc(sizeof(struct nodech));
    new_node->next = (*head);
    new_node->cir  = cir_comp;
    (*head)   	   = new_node;
}

void push_vis(struct nodevis** head,int net, int x,int y){
    struct nodevis* new_node = (struct nodevis*)malloc(sizeof(struct nodevis));
    new_node->next = (*head);
    new_node->data = net;
    new_node->x = x;
    new_node->y = y;
    (*head)    = new_node;
}

struct nodevis* search_vis(struct nodevis* head,int data){
	struct nodevis* new_node=NULL;
	new_node=head;
	while(new_node!=NULL){
		if(new_node->data==data)
			return new_node;
		new_node=new_node->next;
	}
	return NULL;
}

struct nodemain* search_main(struct nodemain* head,int data){
	struct nodemain* new_node=head;
	//printf("enters search main \n");
	while(new_node!=NULL){
		//printf("%d,%d",new_node->net,data);
		if(new_node->net==data){
			//printf("yes\n");
			return new_node;
		}
		new_node=new_node->next;
	}
	return NULL;
}

int cmp_struct(circuit_component a,circuit_component b){

	if(a.type!=b.type)
		return 0;
	if(a.type_num!=b.type_num)
		return 0;
	if(a.from_net!=b.from_net)
		return 0;
	if(a.to_net!=b.to_net)
		return 0;
	return 1;
}

struct nodech* search_child(struct nodemain* head,circuit_component data){
	struct nodech* new_node=head->child;
	while(new_node!=NULL){
		if(cmp_struct(data,new_node->cir)==1)
			return new_node;
		new_node=new_node->next;
	}
	return NULL;
}

void add_to_graph(struct nodemain** headmain,circuit_component comp){

	struct nodech* ch;
	//printf("**%d**\n",comp.from_net);
	struct nodemain* from_node=search_main((*headmain),comp.from_net);	
	if(from_node==NULL){
		count++;
		from_node=push_main(headmain,comp.from_net);
		//printf("\n\n&&  %d  &&\n\n",comp.from_net);
	}
	struct nodech* child1=search_child(from_node,comp);
	if(child1==NULL){
		ch=from_node->child;
		push_struct(&ch,comp);
		from_node->child=ch;
	}

	struct nodemain* to_node=search_main((*headmain),comp.to_net);	
	if(to_node==NULL){
		count++;
		to_node=push_main(headmain,comp.to_net);
		//printf("\n\n&&  %d  &&\n\n",comp.to_net);
	}
	child1=search_child(to_node,comp);
	if(child1==NULL){
		ch=to_node->child;
		push_struct(&ch,comp);
		to_node->child=ch;
	}
	compc++;
}


/*
  <text x="10" y="20" style="fill:red;">Several lines:
    <tspan x="10" y="45">First line.</tspan>
    <tspan x="10" y="70">Second line.</tspan>
  </text>
*/

void printplus(int x,int y){
	printf("<text x=\"%d\" y=\"%d\" stroke = \"black\" font-size=\"20\">+</text>\n",x,y);
}

void printNet(int x,int y,int net){
	if(net==-1)
    		printf("<text x=\"%d\" y=\"%d\" stroke = \"red\" font-size=\"10\">Gnd</text>\n",x,y);
	else
    		printf("<text x=\"%d\" y=\"%d\" stroke = \"red\" font-size=\"10\">Net%d</text>\n",x,y,net);
}

void printRLC(int x,int y,char a,int RLCval,int val,char *s){

	printf("<text x=\"%d\" y=\"%d\" stroke = \"red\" font-size=\"10\">%c%d %d%s</text>\n",x,y,a,RLCval,val,s);
}

void printVI(int x,int y,int a ,int b,int c,char* s,int d,int e){
	printf("<text x=\"%d\" y=\"%d\" stroke = \"red\" font-size=\"10\">SINE ( %d %d %d%s %dS %d )</text>\n",x,y,a,b,c,s,d,e);
}

void draw_vcap(int x,int y,int c){			//sx=>start x, ex=>ending x 

    printf("<path d=\"M %d,%d L %d, %d M %d,%d L %d, %d M %d,%d L %d, %d M %d,%d L %d, %d M %d,%d \" \n style=\" fill:none;fill-opacity:0.75;fill-rule:evenodd;stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\n\"/>\n",x,y,x,y-c,x-c,y-c,x+c,y-c,x-c,y-2*c,x+c,y-2*c ,x,y-2*c,x,y-3*c,x,y-3*c);

endx=x;
endy=y-3*c;

}

void draw_vind(int x,int y,int c){
	printf("<path d=\"M %d,%d L %d,%d C %d,%d %d,%d %d,%d C %d,%d %d,%d %d,%d C %d,%d %d,%d %d,%d C %d,%d %d,%d %d,%d C %d,%d %d,%d %d,%d C %d,%d %d,%d %d,%d L %d,%d M %d,%d \" \n style=\" fill:none;fill-opacity:0.75;fill-rule:evenodd;stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\n\"/>\n",x,y,x,y-c,x,y-c, x+c/2,y-c, x+c/2,y-3*c/2,x+c/2,y-3*c/2, x+c/2,y-2*c, x,y-2*c,x,y-2*c, x+c/2,y-2*c, x+c/2,y-5*c/2,x+c/2,y-5*c/2, x+c/2,y-3*c, x,y-3*c,x,y-3*c, x+c/2,y-3*c, x+c/2,y-7*c/2,x+c/2,y-7*c/2, x+c/2,y-4*c, x,y-4*c,x,y-5*c,x,y-5*c);

endx=x;
endy=y-5*c;
}

void draw_vres(int x,int y,int c){

	printf("<path d=\"M %d,%d L %d,%d L %d,%d L %d,%d L %d,%d L %d,%d L %d,%d M %d,%d \" \n style=\" fill:none;fill-opacity:0.75;fill-rule:evenodd;stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\n\"/>\n",x,y, x,y-c ,x+c/2,y-3*c/2, x,y-2*c ,x+c/2,y-5*c/2,x,y-3*c ,x,y-4*c,x,y-4*c);


endx=x;
endy=y-4*c;
}


void draw_cur(int x,int y,int c){

	printf("<circle cx=\"%d\" cy=\"%d\" r=\"%d\" stroke=\"black\" stroke-width=\"1\" fill=\"white\" />\n",x,y-2*c,c);

	printf("<polygon points=\"%d,%d %d,%d %d,%d \" style=\"fill:black;stroke:black;stroke-width:1\" />\n",x,y-8*c/3, x-c/2,y-2*c, x+c/2,y-2*c);

	printf("<path d=\"M %d,%d L %d,%d M %d,%d L %d,%d M %d,%d L %d,%d M %d,%d \" \n style=\" fill:none;fill-opacity:0.75;fill-rule:evenodd;stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\n\"/>\n",x,y,x,y-c,x,y-4*c/3,x,y-8*c/3,x,y-3*c,x,y-4*c,x,y-4*c);

endx=x;
endy=y-4*c;
}

void draw_volt(int x,int y,int c){

	printf("<circle cx=\"%d\" cy=\"%d\" r=\"%d\" stroke=\"black\" stroke-width=\"1\" fill=\"white\" />\n",x,y-2*c,c);

	printf("<path d=\"C %d,%d %d,%d %d,%d C %d,%d %d,%d %d,%d C %d,%d %d,%d %d,%d C %d,%d %d,%d %d,%d \" \n style=\" fill:none;fill-opacity:0.75;fill-rule:evenodd;stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\n\"/>\n",x-c/2,y-2*c,x-c/2,y-5*c/2,x-c/4,y-5*c/2,x-c/4,y-5*c/2,x,y-5*c/2,x,y-2*c,x,y-2*c,x,y-3*c/2,x+c/4,y-3*c/2,x+c/4,y-3*c/2,x+c/2,y-3*c/2,x+c/2,y-2*c);

	printf("<path d=\"M %d,%d L %d,%d M %d,%d L %d,%d M %d,%d \" \n style=\" fill:none;fill-opacity:0.75;fill-rule:evenodd;stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\n\"/>\n",x,y,x,y-c,x,y-3*c,x,y-4*c,x,y-4*c);

	endx=x;
	endy=y-4*c;
}

void dot(int x,int y,int c){
	printf("<circle cx=\"%d\" cy=\"%d\" r=\"%d\" stroke=\"black\" stroke-width=\"1\" fill=\"black\" />\n",x,y,c);
}

void draw_line_to(int x,int y){
	printf("<path d=\"L %d,%d \" \n style=\" fill:none;fill-opacity:0.75;fill-rule:evenodd;stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\n\"/>\n",x,y);
}

void draw_line(int x,int y,int x2,int y2){
	printf("<path d=\"M %d,%d L %d,%d \" \n style=\" fill:none;fill-opacity:0.75;fill-rule:evenodd;stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\n\"/>\n",x,y,x2,y2);
}


void draw_graph(struct nodemain* headmain){
	screenx=50*(compc+2);
	screeny=50*(count+2);
	int x=30;	
	int y=screeny-10;
	dot(x,y,5);
	//printf("%d\n\n",y);
	//dot(fp,x,y+250,60);
	
	int count_net=0;
	int count_comp=0;
	struct nodevis* vis=NULL;
	struct nodevis* drawn=NULL;

	struct nodemain* temp=headmain;

	push_vis(&drawn,-1,x,y-50*count_net);
	dot(x,y-50*count_net,5);
	printNet(x-25,y-50*count_net-5,-1);
	count_net++;

	while(temp!=NULL){
		if(temp->net!=-1){
			push_vis(&drawn,temp->net,x,y-50*count_net);
			dot(x,y-50*count_net,5);
			printNet(x-25,y-50*count_net-5,temp->net);
			count_net++;
		}
			temp=temp->next;
	}



	temp=headmain;
	while(temp!=NULL){

		int startx,starty;

		struct nodevis* checkdr=search_vis(drawn,temp->net);
		startx=checkdr->x;
		starty=checkdr->y;
		
		push_vis(&vis,temp->net,x,y);
	
//	printf("\n");
		int check_if_open=0;
		struct nodech* tempch=temp->child;
		while(tempch!=NULL){
			check_if_open++;
			int opp_net;
			if(tempch->cir.from_net==temp->net)
				opp_net=tempch->cir.to_net;
			else opp_net=tempch->cir.from_net;
			struct nodevis* opp_node=search_vis(vis,opp_net);
			
			if(opp_node==NULL){
				opp_node=search_vis(drawn,opp_net);
				int oppx=opp_node->x;
				int oppy=opp_node->y;

				int drawx=x+10+count_comp*50;
				draw_line(startx,starty,drawx,starty);
				char type=tempch->cir.type;
				//printf("%c\n",type);
				switch(type){
					case 'R':	//printf("were you here?\n");
							//printf("$$%s$$\n",tempch->cir.RLCdenom);
							draw_vres(drawx,starty,10);
							
							if(strcmp(tempch->cir.RLCdenom,"ohm")){
								printRLC(endx,endy+10,'R',tempch->cir.type_num,tempch->cir.RLCval,"");break;}
							else printRLC(endx,endy+10,'R',tempch->cir.type_num,tempch->cir.RLCval,tempch->cir.RLCdenom);break;
					case 'L':
							draw_vind(drawx,starty,10);
							printRLC(endx+3,endy+20,'L',tempch->cir.type_num,tempch->cir.RLCval,tempch->cir.RLCdenom);break;
					case 'C':
							draw_vcap(drawx,starty,10);
							printRLC(endx,endy,'C',tempch->cir.type_num,tempch->cir.RLCval,tempch->cir.RLCdenom);break;
					case 'V':	
							draw_volt(drawx,starty,10);
							printVI(endx,endy,tempch->cir.DC_offset,tempch->cir.amp,tempch->cir.freq,tempch->cir.freqdenom,tempch->cir.delay,tempch->cir.damp);
							if(temp->net==(tempch->cir.from_net))
								printplus(drawx,starty);
							else printplus(endx+5,endy+15);
							break;
					case 'I':	//printf("here?");
							draw_cur(drawx,starty,10);
							printVI(endx,endy,tempch->cir.DC_offset,tempch->cir.amp,tempch->cir.freq,tempch->cir.freqdenom,tempch->cir.delay,tempch->cir.damp);
							if(temp->net==(tempch->cir.from_net))
								printplus(drawx,starty);
							else printplus(endx+5,endy+15);				
							break;

				}
				draw_line(endx,endy,drawx,oppy);
				dot(drawx,oppy,5);
				draw_line(drawx,oppy,oppx,oppy);
				count_comp++;
			}
			tempch=tempch->next;

		}
		if(check_if_open==1){
			fprintf(stderr,"open_circuit");
			exit(0);
		}
		temp=temp->next;
	}


}

complex* calc_impedance(circuit_component cir,float freq){
	complex* c=malloc(sizeof(complex));
	if(cir.type=='R'){
		c->R_part = cir.RLCval;
		c->C_part = 0 ;
	}

	else if(cir.type == 'C'){
		c->C_part = -1/(cir.RLCval*freq);
		c->R_part = 0;
	}

	else if(cir.type == 'L'){
		c->C_part = cir.RLCval*freq;
		c->R_part = 0;
	}
	return c;
}


void print_array(complex ***array_of_coeff,int n){
	int i,j;
	for(i =0 ; i < n; i++){
		for(j =0 ; j < n; j++){

			printf("[%f+i%f]" ,array_of_coeff[i][j]->R_part ,array_of_coeff[i][j]->C_part);

		}
		printf("\n");
	}	

}

complex* ret_zero(){

	complex* real1=malloc(sizeof(complex));
	real1->R_part=0;
	real1->C_part=0;
	return real1;
}


void add_to_eq(complex** primary_array_of_coeff ,int id ,complex* val){

	primary_array_of_coeff[id]=add_complex(primary_array_of_coeff[id] ,val);

}

void add_to_seteqns(complex*** array_of_coeff, int from, complex** primary_array_of_coeff){

	array_of_coeff[from]=primary_array_of_coeff;

}

int search_volt_pos(int net, int* volts){

	int i=0;
	for( i=0; i < count-1 ;i++){

		if(volts[i] == net)
			return i;
	}

	return -2;								//default case
}

void analyze(struct nodemain* headmain ,int n ,float freq ,complex*** array_of_coeff ,complex** RHS){

	struct nodemain* temp=headmain;
	int gnd = temp->net;
	temp=temp->next;

	int volt[count-1];
	int *volt_variables=volt;
	int i=0,j;
	
	while(temp!=NULL){

		volt_variables[i]=temp->net;
		temp=temp->next;
	}

	temp=headmain;
	temp=temp->next;

	while(temp!=NULL){

		int from=temp->net;

		from = search_volt_pos(from, volt_variables);		
		int to;
		
		complex** primary_array_of_coeff = (complex**)malloc(sizeof(complex)*n);
		for (i = 0; i < count-1; ++i)
		{
			primary_array_of_coeff[i]=ret_zero();
		}

		struct nodech* tempch=temp->child;
		while(tempch!=NULL){

			

			complex* imp = calc_impedance(tempch->cir ,freq);
			
			to = tempch->cir.to_net;
			if (to != gnd)
				to = search_volt_pos(to, volt_variables);

			complex* one = malloc(sizeof(complex));
			one->R_part = 1;
			one->C_part = 0;

			complex* pos_constant = div_complex(one,imp);

			complex* neg_constant = minus_complex(ret_zero(), pos_constant);
	
			add_to_eq(primary_array_of_coeff ,from ,neg_constant );			
			if (to != gnd)		
				add_to_eq(primary_array_of_coeff ,to ,pos_constant );		

			tempch=tempch->next;

		}

		add_to_seteqns(array_of_coeff ,from ,primary_array_of_coeff);
		temp=temp->next;
	}				

} 

void printList(struct nodemain* node){
	struct nodech* ch=node->child;
	printf("** net name =%d**\n",node->net);
	while(ch!=NULL){
	printf("%c\n",ch->cir.type);//rlcvi
	printf("%d\n",ch->cir.type_num);
	printf("%d\n",ch->cir.from_net);
	printf("%d\n",ch->cir.to_net);
	printf("%f\n",ch->cir.RLCval);
	printf("%f\n",ch->cir.DC_offset);
	printf("%f\n",ch->cir.amp);
	printf("%f\n",ch->cir.freq);
	printf("%f\n",ch->cir.delay);
	printf("%f\n",ch->cir.damp);

	printf("\n\n");
		
	ch=ch->next;
	}
}

